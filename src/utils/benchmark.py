# -*- coding: utf-8 -*-
import math

# TSPLIB canonic rounding.
def nint(x):
  return int(x + 0.5);

def euc_2D(c1, c2):
  xd = c1[0] - c2[0]
  yd = c1[1] - c2[1]
  return nint(math.sqrt(xd * xd + yd * yd))

# Retrieve value for a one-liner TSPLIB entry.
def get_value(key, lines):
  result = None

  match = filter(lambda s: (s).startswith(key + ':'), lines)
  if len(match) > 0:
    result = match[0][len(key) + 1:].strip()
  else:
    # Also try with a space.
    match = filter(lambda s: (s).startswith(key + ' :'), lines)
    if len(match) > 0:
      result = match[0][len(key) + 2:].strip()

  return result

def parse_node_coords(s):
  # Separate index and coordinates.
  coords = s.strip().split(' ')
  # Remove empty entries generated by multiple spaces.
  return [v for v in coords if len(v) > 0]

# Compute matrix based on ordered list of coordinates.
def get_matrix(coords):
  matrix = []

  for i in range(len(coords)):
    line = []
    for j in range(len(coords)):
      # Should take symmetry into account to halve operations.
      line.append(euc_2D(coords[i], coords[j]))
    matrix.append(line)

  return matrix
