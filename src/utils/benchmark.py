# -*- coding: utf-8 -*-
import math


# TSPLIB canonic rounding.
def nint(x):
    return int(x + 0.5)


def euc_2D(c1, c2, PRECISION=1):
    xd = c1[0] - c2[0]
    yd = c1[1] - c2[1]
    return nint(PRECISION * math.sqrt(xd * xd + yd * yd))


# Retrieve value for a one-liner TSPLIB entry.
def get_value(key, lines):
    result = None

    match = list(filter(lambda s: (s).startswith(key + ":"), lines))
    if len(match) > 0:
        result = match[0][len(key) + 1 :].strip()
    else:
        # Also try with a space.
        match = list(filter(lambda s: (s).startswith(key + " :"), lines))
        if len(match) > 0:
            result = match[0][len(key) + 2 :].strip()

    return result


def parse_node_coords(s):
    # Separate index and coordinates.
    coords = s.strip().split(" ")
    # Remove empty entries generated by multiple spaces.
    coord_line = [v for v in coords if len(v) > 0]

    if len(coord_line) < 3:
        # Reaching another section (like DEMAND_SECTION), happens when
        # only jobs are listed in NODE_COORD_SECTION but DIMENSION
        # count include jobs + depot.
        return None

    return {
        "id": int(coord_line[0]),
        "location": [float(coord_line[1]), float(coord_line[2])],
    }


def parse_demand(s):
    # Separate index and value.
    fields = s.strip().split(" ")
    # Remove empty entries generated by multiple spaces.
    return [v for v in fields if len(v) > 0]


# Compute matrix based on ordered list of coordinates.
def get_matrix(coords, PRECISION=1):
    N = len(coords)
    matrix = [[0 for i in range(N)] for j in range(N)]

    for i in range(N):
        for j in range(i + 1, N):
            value = euc_2D(coords[i], coords[j], PRECISION)
            matrix[i][j] = value
            matrix[j][i] = value

    return matrix
